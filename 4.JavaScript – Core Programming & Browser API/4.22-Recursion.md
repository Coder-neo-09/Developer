# 🔁 JavaScript Recursion

---

## 📖 Definition

**Recursion** is a technique where a **function calls itself** until it reaches a **base condition** (stopping point).

It’s commonly used for:

* Breaking down complex problems into smaller ones
* Working with **nested structures** (trees, directories, JSON, etc.)
* Replacing loops in some cases

---

## 🔍 Characteristics of Recursion

| Feature                     | Recursion ✅                           |
| --------------------------- | ------------------------------------- |
| Function calls itself       | Yes                                   |
| Needs base condition        | Yes (to avoid infinite loop)          |
| Breaks big problems smaller | Yes                                   |
| Can replace loops           | Yes (not always efficient)            |
| Used in real-world problems | Yes (factorial, Fibonacci, tree data) |

---

## 📦 Example – Simple Recursion

```javascript
function countdown(n) {
  if (n === 0) {
    console.log("Done!");
    return;
  }
  console.log(n);
  countdown(n - 1); // recursive call
}

countdown(5);
// Output: 5 4 3 2 1 Done!
```

💡 Here, the function keeps calling itself with `n-1` until it reaches `0` (base case).

---

## 📦 Example – Factorial (Classic Recursion)

```javascript
function factorial(n) {
  if (n === 0) return 1; // base case
  return n * factorial(n - 1); // recursive case
}

console.log(factorial(5)); // 120
```

💡 Each call multiplies `n` by the factorial of `n-1` until it reaches the base case.

---

## ⚠ Non-Recursive Function (for comparison)

```javascript
function factorialIterative(n) {
  let result = 1;
  for (let i = 1; i <= n; i++) {
    result *= i;
  }
  return result;
}

console.log(factorialIterative(5)); // 120
```

This works **without recursion** using a loop.

---

## 🌍 Real-World Example – Traversing Nested Objects

```javascript
const user = {
  name: "Ramya",
  details: {
    age: 22,
    address: {
      city: "Hyderabad",
      country: "India"
    }
  }
};

function printValues(obj) {
  for (let key in obj) {
    if (typeof obj[key] === "object") {
      printValues(obj[key]); // recursive call
    } else {
      console.log(`${key}: ${obj[key]}`);
    }
  }
}

printValues(user);

// Output:
// name: Ramya
// age: 22
// city: Hyderabad
// country: India
```

💡 Recursion is perfect for **nested structures** like JSON or directory trees.

---

## 🛑 Real-World Example – Without Recursion (Longer Code)

```javascript
const numbers = [1, [2, [3, [4, 5]]]];

// Flatten without recursion (manual, harder)
console.log([1, 2, 3, 4, 5]);
```

This works, but recursion makes it much cleaner:

```javascript
function flatten(arr) {
  let result = [];
  for (let item of arr) {
    if (Array.isArray(item)) {
      result = result.concat(flatten(item)); // recursive call
    } else {
      result.push(item);
    }
  }
  return result;
}

console.log(flatten(numbers)); // [1, 2, 3, 4, 5]
```

---

## ✅ Summary Table

| Rule of Recursion    | Meaning                                    |
| -------------------- | ------------------------------------------ |
| Base case required   | Prevents infinite recursion                |
| Recursive case       | Function calls itself with smaller input   |
| Used for             | Factorials, Fibonacci, tree/graph problems |
| Alternative to loops | Sometimes simpler, but can use loops too   |

---

## 🧠 Best Practices for Recursion

1. **Always define a base case** (to stop recursion).
2. **Use recursion for hierarchical/nested data** (trees, graphs, JSON).
3. **Avoid deep recursion** in JavaScript (stack overflow risk).
4. **Consider iterative solutions** if recursion is too expensive.
5. **Use tail recursion** (if possible) for performance (though JS doesn’t optimize it well).
