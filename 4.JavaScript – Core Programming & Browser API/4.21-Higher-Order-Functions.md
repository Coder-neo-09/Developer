# 🚀 Higher-Order Functions (HOFs)

---

## 📖 Definition

A **Higher-Order Function (HOF)** is a function that **either**:

1. **Takes another function as an argument** (callback function), OR
2. **Returns a function as its result**.

This makes them extremely powerful in **functional programming**.

---

## 🔍 Characteristics of Higher-Order Functions

| Feature                        | Higher-Order Function ✅         |
| ------------------------------ | ------------------------------- |
| Accepts functions as arguments | Yes                             |
| Returns a function             | Yes                             |
| Improves reusability           | Yes                             |
| Enables abstraction            | Yes                             |
| Used in built-in JS methods    | Yes (`map`, `filter`, `reduce`) |

---

## 📦 Example – Higher-Order Function (Takes Function as Argument)

```javascript
function greet(name) {
  return "Hello, " + name;
}

function processUserInput(callback) {
  const name = "Ramya";
  return callback(name); // callback function
}

console.log(processUserInput(greet)); // "Hello, Ramya"
```

💡 Here, `processUserInput` is a **higher-order function** because it accepts another function (`greet`) as an argument.

---

## 📦 Example – Higher-Order Function (Returns a Function)

```javascript
function multiplier(factor) {
  return function (number) {
    return number * factor;
  };
}

const double = multiplier(2);
console.log(double(5)); // 10

const triple = multiplier(3);
console.log(triple(5)); // 15
```

💡 Here, `multiplier` is a **higher-order function** because it returns another function.

---

## ⚠ Non Higher-Order Function (for comparison)

```javascript
function add(a, b) {
  return a + b; // Simple function, not higher-order
}

console.log(add(2, 3)); // 5
```

This is **not higher-order** because it neither accepts nor returns a function.

---

## 🌍 Real-World Example – Array Methods (HOFs in Action)

Many built-in array methods in JavaScript are higher-order functions:

```javascript
const prices = [100, 200, 300, 400];

// 1. map → transforms each value
const withTax = prices.map(price => price * 1.1);
console.log(withTax); // [110, 220, 330, 440]

// 2. filter → selects based on condition
const expensive = prices.filter(price => price > 250);
console.log(expensive); // [300, 400]

// 3. reduce → combines into a single value
const total = prices.reduce((sum, price) => sum + price, 0);
console.log(total); // 1000
```

💡 All of these are **higher-order functions** because they take callback functions as arguments.

---

## 🛑 Real-World Example – Without HOFs (Longer Code)

```javascript
const numbers = [1, 2, 3, 4, 5];
let doubled = [];

for (let i = 0; i < numbers.length; i++) {
  doubled.push(numbers[i] * 2);
}

console.log(doubled); // [2, 4, 6, 8, 10]
```

This works, but is **longer and less reusable** than using `map`.

---

## ✅ Summary Table

| Rule of HOFs         | Meaning                                   |
| -------------------- | ----------------------------------------- |
| Accepts functions    | Can take callbacks as parameters          |
| Returns functions    | Can generate and return new functions     |
| Improves reusability | Write once, use anywhere                  |
| Core in JS arrays    | `map`, `filter`, `reduce`, `forEach` etc. |

---

## 🧠 Best Practices for Higher-Order Functions

1. **Use built-in HOFs (`map`, `filter`, `reduce`)** instead of manual loops for clarity.
2. **Keep callbacks pure** (avoid side effects).
3. **Use arrow functions** for short callbacks to make code concise.
4. **Name your callbacks** if they are reused in multiple places.
5. **Combine HOFs** for powerful data transformations.
