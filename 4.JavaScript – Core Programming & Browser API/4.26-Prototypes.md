# ðŸ§© JavaScript Prototypes  

---

## ðŸ“– Definition  

Every JavaScript object has a hidden property called **prototype**, which is another object it inherits properties and methods from.  
This forms a **prototype chain**, the foundation of JavaScriptâ€™s inheritance system.  

ðŸ‘‰ In short:  
- Objects can **share methods** through prototypes.  
- Prototypes make JavaScript **memory efficient**.  

---

## ðŸ” Characteristics of Prototypes  

| Feature                        | Prototype âœ…                              |
| ------------------------------ | ---------------------------------------- |
| Defines inheritance chain      | Yes                                      |
| Shared among objects           | Yes (no duplication of methods)          |
| Accessed via `__proto__`       | Yes (but not recommended, use `Object.getPrototypeOf`) |
| Set by constructor             | Yes                                      |
| Core of JS inheritance model   | Yes                                      |

---

## ðŸ“¦ Example â€“ Default Prototype  

```javascript
const person = { name: "Ramya" };

console.log(person.toString()); 
// [object Object] â†’ inherited from Object.prototype
```

ðŸ’¡ Even though we didnâ€™t define `toString`, the object inherited it from **Object.prototype**.  

---

## ðŸ“¦ Example â€“ Constructor Function with Prototype  

```javascript
function Person(name, age) {
  this.name = name;
  this.age = age;
}

// Add shared method
Person.prototype.greet = function() {
  return `Hello, Iâ€™m ${this.name} and Iâ€™m ${this.age} years old.`;
};

const p1 = new Person("Ramya", 22);
const p2 = new Person("Anu", 21);

console.log(p1.greet()); // Hello, Iâ€™m Ramya and Iâ€™m 22 years old.
console.log(p2.greet()); // Hello, Iâ€™m Anu and Iâ€™m 21 years old.
```

ðŸ’¡ Methods added to `Person.prototype` are **shared across all objects** created using the constructor.  

---

## âš  Without Prototype (Inefficient)  

```javascript
function Car(brand, model) {
  this.brand = brand;
  this.model = model;
  this.getDetails = function() {
    return `${this.brand} ${this.model}`;
  };
}

const car1 = new Car("Tesla", "Model S");
const car2 = new Car("Toyota", "Corolla");

console.log(car1.getDetails());
console.log(car2.getDetails());
```

ðŸ’¡ Here, each car object has its **own copy** of `getDetails` â†’ memory waste.  
Using `Car.prototype.getDetails` is better.  

---

## ðŸŒ Real-World Example â€“ Bank Account with Prototype Methods  

```javascript
function BankAccount(owner, balance) {
  this.owner = owner;
  this.balance = balance;
}

BankAccount.prototype.deposit = function(amount) {
  this.balance += amount;
  return `Deposited â‚¹${amount}, New Balance: â‚¹${this.balance}`;
};

BankAccount.prototype.withdraw = function(amount) {
  if (amount > this.balance) {
    return "Insufficient funds!";
  }
  this.balance -= amount;
  return `Withdrew â‚¹${amount}, New Balance: â‚¹${this.balance}`;
};

const acc1 = new BankAccount("Ramya", 1000);

console.log(acc1.deposit(500));   // Deposited â‚¹500, New Balance: â‚¹1500
console.log(acc1.withdraw(2000)); // Insufficient funds!
```

ðŸ’¡ All `BankAccount` objects share the same `deposit` and `withdraw` methods through the prototype.  

---

## ðŸ“¦ Example â€“ Prototype Chain  

```javascript
const arr = [1, 2, 3];

console.log(arr.__proto__ === Array.prototype); // true
console.log(Array.prototype.__proto__ === Object.prototype); // true
console.log(Object.prototype.__proto__); // null
```

ðŸ’¡ The **prototype chain** ends at `Object.prototype` â†’ the root object.  

---

## âœ… Summary Table  

| Rule of Prototypes       | Meaning                                   |
| -------------------------| ----------------------------------------- |
| Every object has a proto | Inherited from its constructorâ€™s prototype|
| Methods in prototype     | Shared across all instances               |
| Prototype chain          | Enables inheritance hierarchy             |
| Memory efficiency        | Saves memory vs defining methods per object |
| Backbone of JS OOP       | Used in constructors & classes            |

---

## ðŸ§  Best Practices  

1. **Use prototypes for methods** in constructor functions (saves memory).  
2. **Never modify built-in prototypes** (`Array.prototype`, `Object.prototype`) â†’ can break code.  
3. **Use `Object.create()`** for custom prototype-based inheritance.  
4. **Prefer ES6 `class` syntax** (cleaner, but still uses prototypes under the hood).  
5. **Know the prototype chain** â†’ helps debug inheritance issues.  
