# 🧩 JavaScript Prototypes  

---

## 📖 Definition  

Every JavaScript object has a hidden property called **prototype**, which is another object it inherits properties and methods from.  
This forms a **prototype chain**, the foundation of JavaScript’s inheritance system.  

👉 In short:  
- Objects can **share methods** through prototypes.  
- Prototypes make JavaScript **memory efficient**.  

---

## 🔍 Characteristics of Prototypes  

| Feature                        | Prototype ✅                              |
| ------------------------------ | ---------------------------------------- |
| Defines inheritance chain      | Yes                                      |
| Shared among objects           | Yes (no duplication of methods)          |
| Accessed via `__proto__`       | Yes (but not recommended, use `Object.getPrototypeOf`) |
| Set by constructor             | Yes                                      |
| Core of JS inheritance model   | Yes                                      |

---

## 📦 Example – Default Prototype  

```javascript
const person = { name: "Ramya" };

console.log(person.toString()); 
// [object Object] → inherited from Object.prototype
```

💡 Even though we didn’t define `toString`, the object inherited it from **Object.prototype**.  

---

## 📦 Example – Constructor Function with Prototype  

```javascript
function Person(name, age) {
  this.name = name;
  this.age = age;
}

// Add shared method
Person.prototype.greet = function() {
  return `Hello, I’m ${this.name} and I’m ${this.age} years old.`;
};

const p1 = new Person("Ramya", 22);
const p2 = new Person("Anu", 21);

console.log(p1.greet()); // Hello, I’m Ramya and I’m 22 years old.
console.log(p2.greet()); // Hello, I’m Anu and I’m 21 years old.
```

💡 Methods added to `Person.prototype` are **shared across all objects** created using the constructor.  

---

## ⚠ Without Prototype (Inefficient)  

```javascript
function Car(brand, model) {
  this.brand = brand;
  this.model = model;
  this.getDetails = function() {
    return `${this.brand} ${this.model}`;
  };
}

const car1 = new Car("Tesla", "Model S");
const car2 = new Car("Toyota", "Corolla");

console.log(car1.getDetails());
console.log(car2.getDetails());
```

💡 Here, each car object has its **own copy** of `getDetails` → memory waste.  
Using `Car.prototype.getDetails` is better.  

---

## 🌍 Real-World Example – Bank Account with Prototype Methods  

```javascript
function BankAccount(owner, balance) {
  this.owner = owner;
  this.balance = balance;
}

BankAccount.prototype.deposit = function(amount) {
  this.balance += amount;
  return `Deposited ₹${amount}, New Balance: ₹${this.balance}`;
};

BankAccount.prototype.withdraw = function(amount) {
  if (amount > this.balance) {
    return "Insufficient funds!";
  }
  this.balance -= amount;
  return `Withdrew ₹${amount}, New Balance: ₹${this.balance}`;
};

const acc1 = new BankAccount("Ramya", 1000);

console.log(acc1.deposit(500));   // Deposited ₹500, New Balance: ₹1500
console.log(acc1.withdraw(2000)); // Insufficient funds!
```

💡 All `BankAccount` objects share the same `deposit` and `withdraw` methods through the prototype.  

---

## 📦 Example – Prototype Chain  

```javascript
const arr = [1, 2, 3];

console.log(arr.__proto__ === Array.prototype); // true
console.log(Array.prototype.__proto__ === Object.prototype); // true
console.log(Object.prototype.__proto__); // null
```

💡 The **prototype chain** ends at `Object.prototype` → the root object.  

---

## ✅ Summary Table  

| Rule of Prototypes       | Meaning                                   |
| -------------------------| ----------------------------------------- |
| Every object has a proto | Inherited from its constructor’s prototype|
| Methods in prototype     | Shared across all instances               |
| Prototype chain          | Enables inheritance hierarchy             |
| Memory efficiency        | Saves memory vs defining methods per object |
| Backbone of JS OOP       | Used in constructors & classes            |

---

## 🧠 Best Practices  

1. **Use prototypes for methods** in constructor functions (saves memory).  
2. **Never modify built-in prototypes** (`Array.prototype`, `Object.prototype`) → can break code.  
3. **Use `Object.create()`** for custom prototype-based inheritance.  
4. **Prefer ES6 `class` syntax** (cleaner, but still uses prototypes under the hood).  
5. **Know the prototype chain** → helps debug inheritance issues.  
