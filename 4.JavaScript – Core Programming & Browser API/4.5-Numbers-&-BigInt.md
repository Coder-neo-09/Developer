# 🎯  Numbers & BigInt 

JavaScript uses **Number** and **BigInt** to represent numeric values.

* **Number**: For integers and floating-point numbers within a safe range.
* **BigInt**: For integers beyond that safe range.

---

## 📌 1. JavaScript Numbers

JavaScript’s **Number** type is **double-precision 64-bit binary format (IEEE 754)**.
It can represent both **integer** and **floating-point** values.

```js
let intNum = 42;       // Integer
let floatNum = 3.14;   // Floating-point
```

### **1.1 Special Number Values**

```js
Infinity;    // Positive infinity
-Infinity;   // Negative infinity
NaN;         // Not-a-Number
```

💡 **Example:**

```js
console.log(1 / 0);     // Infinity
console.log("abc" * 2); // NaN
```

---

### **1.2 Number Limits**

```js
Number.MAX_VALUE;          // Largest possible number
Number.MIN_VALUE;          // Smallest positive number
Number.MAX_SAFE_INTEGER;   // 9007199254740991
Number.MIN_SAFE_INTEGER;   // -9007199254740991
```

💡 Beyond **MAX\_SAFE\_INTEGER**, you lose precision — use **BigInt**.

---

### **1.3 Numeric Literals**

```js
let hex = 0xff;       // Hexadecimal (255)
let binary = 0b1010;  // Binary (10)
let octal = 0o755;    // Octal (493)
```

---

### **1.4 Number Methods**

```js
let num = 123.456;

num.toFixed(2);    // "123.46" (rounds to 2 decimals)
num.toString();    // "123.456"
num.toExponential(2); // "1.23e+2"
Number.isInteger(10); // true
Number.isNaN(NaN);    // true
```

---

## 📌 2. JavaScript BigInt

**BigInt** is for integers **larger than `Number.MAX_SAFE_INTEGER`**.
It can represent arbitrarily large integers without losing precision.

```js
let big = 9007199254740995n; // BigInt literal (note the "n")
```

---

### **2.1 Creating BigInt**

```js
let big1 = 123456789012345678901234567890n; // Literal
let big2 = BigInt(42);                      // Constructor
```

---

### **2.2 BigInt Operations**

```js
let a = 10n;
let b = 3n;

console.log(a + b); // 13n
console.log(a - b); // 7n
console.log(a * b); // 30n
console.log(a / b); // 3n (no decimals, rounds down)
console.log(a % b); // 1n
```

💡 **Note:** BigInt **cannot** be mixed directly with `Number` in operations.

```js
10n + 5; // ❌ TypeError
```

✅ You must convert:

```js
Number(10n) + 5; // 15
```

---

### **2.3 Comparisons**

```js
10n > 5n;     // true
10n === 10;   // false (different types)
10n == 10;    // true  (loose equality)
```

---

## 📌 3. Real-World Uses

| Type   | Use Case                                         |
| ------ | ------------------------------------------------ |
| Number | Prices, percentages, scores, measurements        |
| BigInt | Cryptography, large IDs, scientific calculations |

---

## 📌 4. Best Practices

✅ Use **Number** for most calculations.
✅ Use **BigInt** only when precision beyond `MAX_SAFE_INTEGER` is required.
✅ Avoid mixing Number and BigInt types directly.
✅ Use `Number.isNaN()` and `Number.isFinite()` instead of global `isNaN` for accuracy.

---

## 📌 5. Summary Table

| Feature      | Number               | BigInt                  |
| ------------ | -------------------- | ----------------------- |
| Range        | ±(2^53 - 1)          | Arbitrarily large       |
| Precision    | 53 bits              | Unlimited               |
| Decimal      | ✅ Yes                | ❌ No (integer only)     |
| Literal Form | `42`                 | `42n`                   |
| Use Case     | General calculations | Large integer precision |
