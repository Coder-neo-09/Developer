# 🎯 React Hooks

---

## 📖 What are Hooks?
React **Hooks** are special functions that let you “hook into” React features (like state, lifecycle, and context) inside **functional components**. 

👉 Before Hooks (React < 16.8), these features were only available in **class components**.

⚡ With Hooks, functional components can:
* Manage state (`useState`)
* Handle side effects (`useEffect`)
* Access context (`useContext`)
* Optimize performance (`useMemo`, `useCallback`)
* Use refs (`useRef`)
* Create custom reusable hooks

---

## 1️⃣ The Most Common Hooks

### 🔹 `useState`
Manages **state** inside a functional component.
```jsx
import React, { useState } from "react";

function Counter() {
  const [count, setCount] = useState(0);

  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={() => setCount(count + 1)}>Increment</button>
    </div>
  );
}
```
✅ Stores and updates values.

---

### 🔹 `useEffect`
Handles **side effects** (API calls, subscriptions, DOM updates).
```jsx
import React, { useEffect, useState } from "react";

function Users() {
  const [users, setUsers] = useState([]);

  useEffect(() => {
    fetch("https://jsonplaceholder.typicode.com/users")
      .then((res) => res.json())
      .then((data) => setUsers(data));
  }, []);

  return (
    <ul>
      {users.map((u) => (
        <li key={u.id}>{u.name}</li>
      ))}
    </ul>
  );
}
```
✅ Fetches data when the component mounts.

---

### 🔹 `useContext`
Gives access to **global state** via React Context.
```jsx
import React, { createContext, useContext } from "react";

const ThemeContext = createContext("light");

function ThemedButton() {
  const theme = useContext(ThemeContext);
  return <button>{theme} Mode</button>;
}

export default function App() {
  return (
    <ThemeContext.Provider value="dark">
      <ThemedButton />
    </ThemeContext.Provider>
  );
}
```
✅ Access shared values without prop drilling.

---

### 🔹 `useRef`
Stores **mutable values** or references to DOM elements.
```jsx
import React, { useRef } from "react";

function InputFocus() {
  const inputRef = useRef(null);

  const focusInput = () => inputRef.current.focus();

  return (
    <div>
      <input ref={inputRef} type="text" />
      <button onClick={focusInput}>Focus Input</button>
    </div>
  );
}
```
✅ Useful for DOM manipulation and persisting values.

---

### 🔹 `useReducer`
Manages **complex state** using reducer functions.
```jsx
import React, { useReducer } from "react";

function reducer(state, action) {
  switch (action.type) {
    case "increment":
      return { count: state.count + 1 };
    case "decrement":
      return { count: state.count - 1 };
    default:
      return state;
  }
}

function Counter() {
  const [state, dispatch] = useReducer(reducer, { count: 0 });

  return (
    <div>
      <p>{state.count}</p>
      <button onClick={() => dispatch({ type: "increment" })}>+</button>
      <button onClick={() => dispatch({ type: "decrement" })}>-</button>
    </div>
  );
}
```
✅ Great for managing more structured state updates.

---

### 🔹 Performance Hooks
* **`useMemo`** → Memoizes computed values.
* **`useCallback`** → Memoizes functions.
* **`useLayoutEffect`** → Similar to `useEffect`, but runs synchronously after DOM updates.

---

## 2️⃣ Custom Hooks
You can create **your own hooks** by prefixing a function with `use`.
```jsx
import { useState, useEffect } from "react";

function useWindowWidth() {
  const [width, setWidth] = useState(window.innerWidth);

  useEffect(() => {
    const handleResize = () => setWidth(window.innerWidth);
    window.addEventListener("resize", handleResize);
    return () => window.removeEventListener("resize", handleResize);
  }, []);

  return width;
}

export default useWindowWidth;
```
✅ Can be reused across multiple components.

---

## ✅ Best Practices
✔ Use hooks **only inside functional components or custom hooks**.
✔ Follow the **Rules of Hooks**:
   * Call hooks **at the top level** (not inside loops/conditions).
   * Only call hooks from React functions.
✔ Split logic into custom hooks for reusability.
✔ Use memoization (`useMemo`, `useCallback`) for performance.

---

## ✅ Summary
* Hooks allow **functional components** to use React features.
* Common hooks: `useState`, `useEffect`, `useContext`, `useRef`, `useReducer`.
* Advanced hooks: `useMemo`, `useCallback`, `useLayoutEffect`.
* Custom hooks → reusable stateful logic.


