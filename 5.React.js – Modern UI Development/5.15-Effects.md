# 🎯 React Effects (`useEffect`)

---

## 📖 What are Effects?
In React, **effects** let you perform **side effects** in functional components — things that happen outside the normal rendering process.

👉 Examples of side effects:
* Fetching data from an API.
* Updating the DOM directly.
* Setting up subscriptions or timers.

React provides the **`useEffect` hook** to manage these side effects.

---

## 1️⃣ Basic `useEffect` Example
```jsx
import React, { useState, useEffect } from "react";

function Counter() {
  const [count, setCount] = useState(0);

  useEffect(() => {
    document.title = `You clicked ${count} times`;
  }, [count]); // Runs when 'count' changes

  return (
    <div>
      <p>You clicked {count} times</p>
      <button onClick={() => setCount(count + 1)}>Click Me</button>
    </div>
  );
}

export default Counter;
```
✅ Effect updates the **page title** whenever `count` changes.

---

## 2️⃣ Running Only Once (Component Mount)
```jsx
useEffect(() => {
  console.log("Component mounted!");

  // Cleanup function
  return () => console.log("Component unmounted!");
}, []); // Empty dependency → runs only once
```
✅ Useful for initialization logic like **fetching data on mount**.

---

## 3️⃣ Cleanup with `useEffect`
Effects can return a **cleanup function** to avoid memory leaks.

```jsx
import React, { useEffect, useState } from "react";

function Timer() {
  const [seconds, setSeconds] = useState(0);

  useEffect(() => {
    const interval = setInterval(() => {
      setSeconds((prev) => prev + 1);
    }, 1000);

    return () => clearInterval(interval); // Cleanup
  }, []);

  return <p>Timer: {seconds}s</p>;
}

export default Timer;
```
✅ Cleanup ensures **interval stops** when the component unmounts.

---

## 4️⃣ Fetching Data with `useEffect`
```jsx
import React, { useEffect, useState } from "react";

function Users() {
  const [users, setUsers] = useState([]);

  useEffect(() => {
    fetch("https://jsonplaceholder.typicode.com/users")
      .then((res) => res.json())
      .then((data) => setUsers(data));
  }, []);

  return (
    <ul>
      {users.map((user) => (
        <li key={user.id}>{user.name}</li>
      ))}
    </ul>
  );
}

export default Users;
```
✅ Runs **once on mount** and fetches user data.

---

## 5️⃣ Dependency Array Rules
* `[ ]` → Run once (on mount).
* `[stateVar]` → Run when that variable changes.
* No array → Run on **every render**.

---

## ✅ Best Practices
✔ Always declare dependencies correctly → prevents stale data.
✔ Cleanup side effects like **event listeners, subscriptions, and intervals**.
✔ Avoid heavy computations inside `useEffect`; move logic outside or memoize.

---

## ✅ Summary
* `useEffect` → Handles **side effects** in React.
* Runs after render and can be controlled with dependencies.
* Use cleanup functions to avoid memory leaks.
* Great for data fetching, subscriptions, timers, and DOM updates.
