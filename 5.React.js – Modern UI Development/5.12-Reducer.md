# üéØ React Reducer (`useReducer` Hook)

---

## üìñ What is `useReducer`?  
The **`useReducer` hook** is an alternative to `useState` for managing **more complex state logic** in React.  

It is inspired by the **Reducer pattern** (commonly used in Redux):
* **State** ‚Üí represents the current data.
* **Action** ‚Üí describes what happened (type + payload).
* **Reducer function** ‚Üí decides how to update state based on the action.

üëâ Best suited for cases where **multiple state updates depend on one another** or require **predictable transitions**.

---

## 1Ô∏è‚É£ Basic Syntax
```jsx
const [state, dispatch] = useReducer(reducer, initialState);
```

* `reducer` ‚Üí A function `(state, action) => newState`
* `initialState` ‚Üí Starting state value
* `dispatch` ‚Üí Function to send actions

---

## 2Ô∏è‚É£ Example: Counter with `useReducer`
```jsx
import React, { useReducer } from "react";

const initialState = { count: 0 };

function reducer(state, action) {
  switch (action.type) {
    case "increment":
      return { count: state.count + 1 };
    case "decrement":
      return { count: state.count - 1 };
    case "reset":
      return initialState;
    default:
      return state;
  }
}

function Counter() {
  const [state, dispatch] = useReducer(reducer, initialState);

  return (
    <div>
      <h2>Count: {state.count}</h2>
      <button onClick={() => dispatch({ type: "increment" })}>+</button>
      <button onClick={() => dispatch({ type: "decrement" })}>-</button>
      <button onClick={() => dispatch({ type: "reset" })}>Reset</button>
    </div>
  );
}

export default Counter;
```

‚úÖ `dispatch` triggers actions ‚Üí Reducer updates the state predictably.

---

## 3Ô∏è‚É£ Handling Complex State
When managing multiple related values, `useReducer` helps keep logic clear.

```jsx
const initialForm = { username: "", email: "" };

function formReducer(state, action) {
  switch (action.type) {
    case "SET_FIELD":
      return { ...state, [action.field]: action.value };
    case "RESET":
      return initialForm;
    default:
      return state;
  }
}

function Form() {
  const [form, dispatch] = useReducer(formReducer, initialForm);

  const handleChange = (e) => {
    dispatch({ type: "SET_FIELD", field: e.target.name, value: e.target.value });
  };

  const handleSubmit = (e) => {
    e.preventDefault();
    console.log(form);
  };

  return (
    <form onSubmit={handleSubmit}>
      <input name="username" value={form.username} onChange={handleChange} placeholder="Username" />
      <input name="email" value={form.email} onChange={handleChange} placeholder="Email" />
      <button type="submit">Submit</button>
      <button type="button" onClick={() => dispatch({ type: "RESET" })}>Reset</button>
    </form>
  );
}
```

‚úÖ Cleaner and scalable than multiple `useState` calls.

---

## 4Ô∏è‚É£ When to Use `useReducer`
Use `useReducer` if:
* State transitions are **complex**.
* Multiple values depend on one another.
* You want **predictable state updates** (e.g., like Redux).

Use `useState` if:
* State is **simple** (e.g., toggles, inputs).

---

## ‚úÖ Summary
* `useReducer` = State management with a reducer function.
* Best for **complex logic**, avoids messy multiple `useState`s.
* Works well with **Context API** for global state management.

---

## üß† Best Practices
* Keep reducer functions **pure** (no side effects inside).
* Use **action types** as constants for readability.
* Break down complex reducers into **smaller ones** if needed.
