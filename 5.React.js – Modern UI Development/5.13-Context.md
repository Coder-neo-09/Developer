# üéØ React Context API

---

## üìñ What is Context API?
The **Context API** in React allows you to **share state globally** across the component tree **without prop drilling** (passing props manually through every level).

üëâ Think of it as a way to create **global variables** that can be accessed by any component.

---

## 1Ô∏è‚É£ Basic Syntax
```jsx
const MyContext = React.createContext();

function App() {
  return (
    <MyContext.Provider value={/* some value */}>
      <ChildComponent />
    </MyContext.Provider>
  );
}

function ChildComponent() {
  const value = React.useContext(MyContext);
  return <p>{value}</p>;
}
```

* `createContext()` ‚Üí Creates a new Context.
* `Provider` ‚Üí Wraps components and provides value.
* `useContext()` ‚Üí Accesses context value inside a component.

---

## 2Ô∏è‚É£ Example: Theme Context (Light/Dark Mode)
```jsx
import React, { createContext, useContext, useState } from "react";

const ThemeContext = createContext();

function ThemeProvider({ children }) {
  const [theme, setTheme] = useState("light");

  const toggleTheme = () => {
    setTheme((prev) => (prev === "light" ? "dark" : "light"));
  };

  return (
    <ThemeContext.Provider value={{ theme, toggleTheme }}>
      {children}
    </ThemeContext.Provider>
  );
}

function ThemedComponent() {
  const { theme, toggleTheme } = useContext(ThemeContext);
  return (
    <div style={{ background: theme === "light" ? "#fff" : "#333", color: theme === "light" ? "#000" : "#fff", padding: "20px" }}>
      <h2>Current Theme: {theme}</h2>
      <button onClick={toggleTheme}>Toggle Theme</button>
    </div>
  );
}

export default function App() {
  return (
    <ThemeProvider>
      <ThemedComponent />
    </ThemeProvider>
  );
}
```

‚úÖ No need to pass `theme` and `toggleTheme` through multiple props.

---

## 3Ô∏è‚É£ Combining `useReducer` + Context API (Global State)
Context becomes **very powerful** when combined with `useReducer` for global state management.

Example (Global Counter):
```jsx
import React, { createContext, useReducer, useContext } from "react";

const CounterContext = createContext();

function reducer(state, action) {
  switch (action.type) {
    case "increment":
      return { count: state.count + 1 };
    case "decrement":
      return { count: state.count - 1 };
    default:
      return state;
  }
}

function CounterProvider({ children }) {
  const [state, dispatch] = useReducer(reducer, { count: 0 });
  return (
    <CounterContext.Provider value={{ state, dispatch }}>
      {children}
    </CounterContext.Provider>
  );
}

function Counter() {
  const { state, dispatch } = useContext(CounterContext);
  return (
    <div>
      <h2>Count: {state.count}</h2>
      <button onClick={() => dispatch({ type: "increment" })}>+</button>
      <button onClick={() => dispatch({ type: "decrement" })}>-</button>
    </div>
  );
}

export default function App() {
  return (
    <CounterProvider>
      <Counter />
    </CounterProvider>
  );
}
```

‚úÖ Context provides the **global store**, `useReducer` manages state updates.

---

## 4Ô∏è‚É£ When to Use Context API
‚úî Use when:
* Data needs to be accessed by many components.
* Avoiding **prop drilling** is important.
* Global states like **auth, theme, user settings, language**.

‚ùå Avoid when:
* State is local and only used by one component.
* Too many contexts ‚Üí may cause re-renders.

---

## ‚úÖ Summary
* `Context API` helps avoid prop drilling.
* Works best for **global/shared state**.
* Combine with `useReducer` for a **Redux-like pattern**.
* Keep contexts **domain-specific** (e.g., AuthContext, ThemeContext).
