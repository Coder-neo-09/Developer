# 🎯 React State Management  

---

## 📖 What is State Management?  
State management is the process of **controlling and synchronizing application data (state)** across components. It ensures that when the state changes, the **UI updates automatically**.  

In React, state can exist at **different levels**:
* **Local state** → within a single component (via `useState`).
* **Shared state** → passed between multiple components (via props, context).
* **Global state** → accessible throughout the app (via `Context API` or state libraries like Redux, Zustand, or Recoil).  

---

## 1️⃣ Local State (with `useState`)  
For component-specific state:

```jsx
import React, { useState } from "react";

function Counter() {
  const [count, setCount] = useState(0);

  return (
    <div>
      <h1>Count: {count}</h1>
      <button onClick={() => setCount(count + 1)}>Increment</button>
      <button onClick={() => setCount(count - 1)}>Decrement</button>
    </div>
  );
}
```

✅ Simple and effective for isolated states.  

---

## 2️⃣ Complex Local State (`useReducer`)  
For more complex state updates, `useReducer` is preferred:

```jsx
import React, { useReducer } from "react";

function reducer(state, action) {
  switch (action.type) {
    case "increment": return { count: state.count + 1 };
    case "decrement": return { count: state.count - 1 };
    default: return state;
  }
}

function Counter() {
  const [state, dispatch] = useReducer(reducer, { count: 0 });

  return (
    <div>
      <h1>Count: {state.count}</h1>
      <button onClick={() => dispatch({ type: "increment" })}>Increment</button>
      <button onClick={() => dispatch({ type: "decrement" })}>Decrement</button>
    </div>
  );
}
```

✅ Great for managing **multiple related state values** or when logic is complex.  

---

## 3️⃣ Sharing State Between Components  
Sometimes multiple components need the same state. You can **lift state up** to a parent and pass it down as props.

```jsx
function Child({ count }) {
  return <h2>Count in Child: {count}</h2>;
}

function Parent() {
  const [count, setCount] = useState(0);

  return (
    <div>
      <h1>Parent Count: {count}</h1>
      <button onClick={() => setCount(count + 1)}>Increase</button>
      <Child count={count} />
    </div>
  );
}
```

✅ This avoids duplicate states across components.  

---

## 4️⃣ Global State (Context API)  
For app-wide state sharing without **prop drilling**:

```jsx
import React, { createContext, useContext, useState } from "react";

const ThemeContext = createContext();

function ThemeProvider({ children }) {
  const [darkMode, setDarkMode] = useState(false);
  return (
    <ThemeContext.Provider value={{ darkMode, setDarkMode }}>
      {children}
    </ThemeContext.Provider>
  );
}

function ThemeToggler() {
  const { darkMode, setDarkMode } = useContext(ThemeContext);
  return (
    <button onClick={() => setDarkMode(!darkMode)}>
      Switch to {darkMode ? "Light" : "Dark"} Mode
    </button>
  );
}

export default function App() {
  return (
    <ThemeProvider>
      <ThemeToggler />
    </ThemeProvider>
  );
}
```

✅ Avoids prop drilling and keeps global state clean.  

---

## 5️⃣ State Management Libraries  
For **large-scale apps**, React’s built-in tools might not be enough. Popular libraries:

- **Redux Toolkit** → Centralized, predictable state management.
- **Zustand** → Lightweight and simple state store.
- **Recoil** → Atomic state management by Facebook.
- **Jotai** → Minimal and flexible global state.

---

## ✅ Summary  

| Technique           | Use Case |
|---------------------|----------|
| `useState`          | Local component state ✅ |
| `useReducer`        | Complex local logic ⚡ |
| Lift State Up       | Sharing state across siblings 🔼 |
| `Context API`       | Global state without prop drilling 🌍 |
| Redux / Zustand etc | Enterprise-level apps 🏢 |

---

## 🧠 Best Practices  

* Keep state as **minimal as possible** (don’t duplicate).
* Derive values instead of storing duplicates (e.g., compute from existing state).
* Use **Context API** wisely — avoid overuse to prevent re-renders.
* For **large projects**, adopt Redux Toolkit or Zustand.
