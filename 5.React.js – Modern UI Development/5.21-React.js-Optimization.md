# ⚡ React.js Optimization

Optimizing React applications ensures **faster rendering, better user experience, and lower memory usage**. This guide covers all core optimization techniques with examples and real-world scenarios.

---

## 🎯 1. Avoid Unnecessary Re-Renders
React re-renders components whenever **state or props change**. Avoid passing new objects/arrays/functions inline if not needed.

```jsx
function Parent() {
  const [count, setCount] = React.useState(0);

  const items = React.useMemo(() => [1, 2, 3], []); // memoized array

  return (
    <div>
      <Child items={items} />
      <button onClick={() => setCount(count + 1)}>Increment</button>
    </div>
  );
}
```

---

## 🧠 2. Memoizing Components
Use `React.memo` to prevent unnecessary re-rendering when props do not change.

```jsx
const Child = React.memo(({ items }) => {
  console.log("Child rendered");
  return <div>{items.join(", ")}</div>;
});
```

✅ Ideal for **pure functional components**.

---

## 🧰 3. useCallback & useMemo
- **`useCallback`** memoizes functions to prevent creating new instances each render.
- **`useMemo`** memoizes expensive calculations.

```jsx
const handleClick = React.useCallback(() => {
  console.log("Clicked!");
}, []);

const computedValue = React.useMemo(() => heavyCalculation(items), [items]);
```

---

## ⚡ 4. Lazy Loading & Code Splitting
Load components only when needed using `React.lazy` and `Suspense`.

```jsx
const LazyComponent = React.lazy(() => import("./LazyComponent"));

function App() {
  return (
    <React.Suspense fallback={<div>Loading...</div>}>
      <LazyComponent />
    </React.Suspense>
  );
}
```

✅ Reduces **initial bundle size**.

---

## 📊 5. Virtualization for Large Lists
Use libraries like **react-window** or **react-virtualized** to render only visible list items.

```jsx
import { FixedSizeList as List } from 'react-window';

<List height={150} itemCount={1000} itemSize={35} width={300}>
  {({ index, style }) => <div style={style}>Item {index}</div>}
</List>
```

✅ Improves performance for **long lists**.

---

## 🔄 6. Avoid Anonymous Functions in JSX
Passing inline functions causes **re-renders**. Use `useCallback` or separate functions.

```jsx
// Instead of <button onClick={() => doSomething()}></button>
const handleClick = React.useCallback(() => doSomething(), []);
<button onClick={handleClick}></button>
```

---

## 🏗 7. Split Large Components
Break large components into smaller ones to reduce **re-rendering scope** and improve maintainability.

---

## 🧪 8. Profiling & Monitoring
- Use **React DevTools Profiler** to measure performance.
- Identify components that cause slow renders.
- Optimize only bottlenecks.

---

## 📌 Real-World Scenario
- **Dashboard with hundreds of widgets:** Memoize widgets and use virtualization for tables and charts.
- **E-commerce product list:** Lazy load components and images to reduce initial load time.

---

## ✅ Best Practices
1. Use **React.memo** for pure functional components.
2. Use **useCallback** and **useMemo** to prevent unnecessary calculations and function recreations.
3. Split large components into smaller, focused components.
4. Lazy load routes, images, and components.
5. Virtualize long lists for better scrolling performance.
6. Profile your app regularly with **React DevTools**.
